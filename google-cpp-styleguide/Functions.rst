函数规范
========
参数次序
--------
当定义函数的时候，应该先为输入，然后是输出。
    
    .. code::c++
    char∗ strcpy(const char ∗from, char ∗to); //good
    
    char∗ strcpy(char ∗to, to char ∗from); //do not obey
    

C/C++的函数要不就是输入，输出或时既作为输入也作为输出.输入参数一般为传递进去的值或是常量引用，而输出参数以及输入输出参数为指向非常量的指针。当为函数参数排序的时候将输入型参数放在输出型参数的前面。值得注意的是当新增参数的时候不要仅仅是将新增参数放在之前参数的最后面，而应该将其放在输出型参数前。

书写短小的函数
-------------

遵循"Do one thing at a time, and do it well"的基本原则，一个函数，一个借口应该捕捉到最小，最核心的抽象，不要在一个接口上实现一堆功能，这是很不好的风格

作为参数的引用
--------------
当引用作为参数时必须是常量引用

    .. code::c++
    void Foo(const string &in, string *out);
    
    
在Google代码中，输入参数为值或是引用而输出参数为指针，这是一个一个很强的传统。输入参数也可以为常量指针，但不容许非常量引用，除非某些传统需要如swap()
    
    然而在某些场合下在输入参数的时候使用const T* 要优于const T&，比如:
    
    - 想传入一个空的指针
    - 函数要保存该输入指针或引用
    
    绝大多数情况下，输入参数应该作为const T&，使用const T*会透露出该输入需要特别对待的信息。在使用const *T而不是const &T的时候好好想想是否有必要这么做,否则使用者会去揣测根本不存在的理由，这会让人很困惑.


默认参数
-----------
在非虚函数上可以使用默认参数






函数重载
------------
只有在读者看到函数调用的地方时不用去刻意判断具体是哪个函数被调用的情况下才使用函数重载,比如
    .. code::c++
    class MyClass 
    {
    public:
        void Analyze(const string &text);
        void Analyze(const char *text, size_t textlen);
    };
    
函数重载的优点
    函数重载容许同名的函数使用不同的参数，这样代码能够更加直观。在模板化的代码中这是必要特性，当使用访问者模式的时候也会比较方便.
    
函数重载的缺点
    如果仅仅以参数类型来区分各重载函数，那么读者需要理解C++复杂的类型匹配规则。在类层次中如果子类只重载了部分父类的某个函数其语意则更加让人困惑。
    
结论
    当不适合用重载函数的时候，可以将类型信息编码入函数名，比如AppendStr(),AppendInt(),而不是Append(std::string),Append(int).如果重载函数是为了接受不同数目的相同类型的参数，可以考虑使用std::vector作为参数并使用initializer_list作为参数.


尾置返回语法
-------------
只有在无法使用常规语法（返回类型前置声明）或是使用常规语法可读性很差的情况下才使用尾置返回语法

定义
    C++容许两种函数声明，之前返回类型在函数名之前，比如:
    
    .. code::c++
    int Foo(int x);
    
    C++11引入了一种新的模式,比如上述声明同样可以采用下面的方式声明:
    
    .. code::c++
    auto foo(int x)->int;
    
尾置返回类型处在函数的作用域内，对于简单返回类型两者之间并无差别，当返回类型为自定义类型或是模板的类型参数的时候则会带来不同

尾置返回类型的优点
    尾置返回类型是lambda表达式声明返回类型的唯一方法,虽然编译器很多时候可以自动判断lambda的返回类型，但并非在所有情况下，而且即便可以自动判断，显式的表明会提高代码的可维护性。当返回类型取决于模板参数类型的情况下，使用后置的方式声明返回类型会使代码可读性更好。
    .. code::c++
    template <class T, class U> auto add(T t, U u) -> decltype(t + u);//更加清楚
    template <class T, class U> decltype(declval<T&>() + declval<U&>()) add(T t, U u);
    
尾置返回类型的缺点
    该声明形式是之前C++,C,Java都不曾出现过的，会让人感觉不同寻常，C++11标准前使用的都是前置的形式，且后置的形式并没有带来明显的优点，为了保持风格一致还是应该采用前置的形式，只有在某些特别场合才使用后置形式。
    
结论:
    只有在确有必要的时候使用后置的形式，比如在lambda以及元语言编程中。
